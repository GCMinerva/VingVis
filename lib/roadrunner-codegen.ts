import { Waypoint } from '@/components/interactive-field-canvas'

export type RoadRunnerConfig = {
  projectName: string
  waypoints: Waypoint[]
  driveClass: 'SampleMecanumDrive' | 'SampleTankDrive'
  constraints: {
    maxVel: number
    maxAccel: number
    maxAngVel: number
    maxAngAccel: number
    trackWidth: number
  }
  useAdvancedTrajectories: boolean
}

export function generateRoadRunnerCode(config: RoadRunnerConfig): string {
  const {
    projectName,
    waypoints,
    driveClass,
    constraints,
    useAdvancedTrajectories
  } = config

  if (waypoints.length === 0) {
    return '// No waypoints defined'
  }

  const className = projectName.replace(/[^a-zA-Z0-9]/g, '') + 'AutoRR'
  const startWaypoint = waypoints[0]

  let code = `package org.firstinspires.ftc.teamcode;

import com.acmerobotics.roadrunner.geometry.Pose2d;
import com.acmerobotics.roadrunner.geometry.Vector2d;
import com.acmerobotics.roadrunner.trajectory.Trajectory;
import com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;
import com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryAccelerationConstraint;
import com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryVelocityConstraint;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;

import org.firstinspires.ftc.teamcode.drive.${driveClass};
import org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequence;

/**
 * Generated by VingVis - Robot Path Planner
 * Visit: https://vingvis.com
 *
 * This autonomous routine uses Road Runner for precise path following.
 * Make sure to tune your Road Runner parameters before running!
 */
@Autonomous(name = "${projectName} (RoadRunner)")
public class ${className} extends LinearOpMode {

    @Override
    public void runOpMode() throws InterruptedException {
        // Initialize drive
        ${driveClass} drive = new ${driveClass}(hardwareMap);

        // Starting pose: x=${startWaypoint.x}", y=${startWaypoint.y}", heading=${startWaypoint.heading}°
        Pose2d startPose = new Pose2d(${startWaypoint.x}, ${startWaypoint.y}, Math.toRadians(${startWaypoint.heading}));
        drive.setPoseEstimate(startPose);

        ${useAdvancedTrajectories ? generateAdvancedTrajectorySequence(waypoints, constraints) : generateBasicTrajectorySequence(waypoints)}

        // Wait for start
        telemetry.addData("Status", "Initialized");
        telemetry.addData("Starting Position", startPose);
        telemetry.addData("Waypoints", ${waypoints.length});
        telemetry.update();

        waitForStart();

        if (isStopRequested()) return;

        // Run trajectory
        drive.followTrajectorySequence(trajectorySequence);

        // Update telemetry
        while (opModeIsActive() && !isStopRequested()) {
            drive.update();

            Pose2d poseEstimate = drive.getPoseEstimate();
            telemetry.addData("X", poseEstimate.getX());
            telemetry.addData("Y", poseEstimate.getY());
            telemetry.addData("Heading", Math.toDegrees(poseEstimate.getHeading()));
            telemetry.addData("Is Busy", drive.isBusy());
            telemetry.update();

            if (!drive.isBusy()) {
                break;
            }
        }
    }
}
`

  return code
}

function generateBasicTrajectorySequence(waypoints: Waypoint[]): string {
  const startWaypoint = waypoints[0]

  let code = `// Build trajectory sequence
        TrajectorySequence trajectorySequence = drive.trajectorySequenceBuilder(startPose)\n`

  for (let i = 1; i < waypoints.length; i++) {
    const prevWaypoint = waypoints[i - 1]
    const waypoint = waypoints[i]

    code += `                // Waypoint ${i}: (${waypoint.x}", ${waypoint.y}", ${waypoint.heading}°)\n`

    if (waypoint.type === 'bezier' && prevWaypoint.controlPoint1 && prevWaypoint.controlPoint2) {
      // Spline to position with control points (Road Runner doesn't have direct cubic bezier, use splineTo)
      code += `                .splineTo(
                    new Vector2d(${waypoint.x}, ${waypoint.y}),
                    Math.toRadians(${waypoint.heading})
                )\n`
    } else if (waypoint.type === 'spline') {
      // Smooth spline
      code += `                .splineToSplineHeading(
                    new Pose2d(${waypoint.x}, ${waypoint.y}, Math.toRadians(${waypoint.heading})),
                    Math.toRadians(${waypoint.heading})
                )\n`
    } else {
      // Linear (straight line)
      code += `                .lineToLinearHeading(
                    new Pose2d(${waypoint.x}, ${waypoint.y}, Math.toRadians(${waypoint.heading}))
                )\n`
    }

    // Add turn if heading changes significantly without position change
    const distanceMoved = Math.sqrt(
      (waypoint.x - prevWaypoint.x) ** 2 + (waypoint.y - prevWaypoint.y) ** 2
    )
    const headingChange = Math.abs(waypoint.heading - prevWaypoint.heading)

    if (distanceMoved < 1 && headingChange > 5) {
      code += `                .turn(Math.toRadians(${waypoint.heading - prevWaypoint.heading}))\n`
    }
  }

  code += `                .build();`

  return code
}

function generateAdvancedTrajectorySequence(
  waypoints: Waypoint[],
  constraints: RoadRunnerConfig['constraints']
): string {
  const startWaypoint = waypoints[0]

  let code = `// Custom velocity and acceleration constraints
        TrajectoryVelocityConstraint velConstraint = (displacement, pose, deriv, baseRobotVel) -> ${constraints.maxVel};
        TrajectoryAccelerationConstraint accelConstraint = (displacement, pose, deriv, baseRobotVel) -> ${constraints.maxAccel};

        // Build advanced trajectory sequence with custom constraints
        TrajectorySequence trajectorySequence = drive.trajectorySequenceBuilder(startPose)\n`

  for (let i = 1; i < waypoints.length; i++) {
    const prevWaypoint = waypoints[i - 1]
    const waypoint = waypoints[i]

    // Apply custom constraints if specified
    const useCustomConstraints =
      (waypoint.maxVelocity && waypoint.maxVelocity !== 50) ||
      (waypoint.maxAcceleration && waypoint.maxAcceleration !== 30)

    if (useCustomConstraints) {
      code += `                // Waypoint ${i} with custom constraints: v=${waypoint.maxVelocity || 50}, a=${waypoint.maxAcceleration || 30}\n`
      code += `                .setVelConstraint((displacement, pose, deriv, baseRobotVel) -> ${waypoint.maxVelocity || 50})\n`
      code += `                .setAccelConstraint((displacement, pose, deriv, baseRobotVel) -> ${waypoint.maxAcceleration || 30})\n`
    } else {
      code += `                // Waypoint ${i}: (${waypoint.x}", ${waypoint.y}", ${waypoint.heading}°)\n`
    }

    if (waypoint.type === 'bezier' && prevWaypoint.controlPoint1 && prevWaypoint.controlPoint2) {
      // Use splineTo for smooth curved paths
      code += `                .splineToConstantHeading(
                    new Vector2d(${waypoint.x}, ${waypoint.y}),
                    Math.toRadians(${(Math.atan2(waypoint.y - prevWaypoint.y, waypoint.x - prevWaypoint.x) * 180) / Math.PI})
                )
                .lineToLinearHeading(new Pose2d(${waypoint.x}, ${waypoint.y}, Math.toRadians(${waypoint.heading})))\n`
    } else if (waypoint.type === 'spline') {
      code += `                .splineToSplineHeading(
                    new Pose2d(${waypoint.x}, ${waypoint.y}, Math.toRadians(${waypoint.heading})),
                    Math.toRadians(${(Math.atan2(waypoint.y - prevWaypoint.y, waypoint.x - prevWaypoint.x) * 180) / Math.PI})
                )\n`
    } else {
      code += `                .lineToLinearHeading(
                    new Pose2d(${waypoint.x}, ${waypoint.y}, Math.toRadians(${waypoint.heading}))
                )\n`
    }

    if (useCustomConstraints) {
      code += `                .resetVelConstraint()
                .resetAccelConstraint()\n`
    }
  }

  code += `                .build();`

  return code
}

export function generateRoadRunnerConfig(constraints: RoadRunnerConfig['constraints']): string {
  return `package org.firstinspires.ftc.teamcode.drive;

import com.acmerobotics.dashboard.config.Config;

/**
 * Constants for Road Runner
 * Generated by VingVis
 */
@Config
public class DriveConstants {
    /*
     * These are motor constants that should be listed online for your motors.
     */
    public static final double TICKS_PER_REV = 537.7; // For GoBILDA 5202/5203 series motors
    public static final double MAX_RPM = 312;

    /*
     * Set RUN_USING_ENCODER to true to enable built-in hub velocity control using drive encoders.
     * Set this flag to false if drive encoders are not present and an alternative localization
     * method is in use (e.g., dead wheels).
     */
    public static boolean RUN_USING_ENCODER = true;
    public static double MOTOR_VELO_PID = 0.0; // Adjust as needed

    /*
     * These are physical constants that can be determined from your robot (including the track
     * width; it will be tuned).
     */
    public static double WHEEL_RADIUS = 1.9685; // in inches
    public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed
    public static double TRACK_WIDTH = ${constraints.trackWidth}; // in inches

    /*
     * These are the feedforward parameters used to model the drive motor behavior. If you are using
     * the built-in velocity PID, *these values are fine as is*. However, if you do not have drive
     * encoders or have elected not to use them for velocity control, these values should be tuned.
     */
    public static double kV = 1.0 / rpmToVelocity(MAX_RPM);
    public static double kA = 0;
    public static double kStatic = 0;

    /*
     * These values are used to generate the trajectories for you robot. To ensure proper operation,
     * the constraints should never exceed ~80% of the robot's actual capabilities. While Road
     * Runner is designed to enable faster autonomous motion, it is a good idea to start small and
     * gradually increase them later after everything is working. All distance units are inches.
     */
    public static double MAX_VEL = ${constraints.maxVel};
    public static double MAX_ACCEL = ${constraints.maxAccel};
    public static double MAX_ANG_VEL = Math.toRadians(${(constraints.maxAngVel * 180) / Math.PI});
    public static double MAX_ANG_ACCEL = Math.toRadians(${(constraints.maxAngAccel * 180) / Math.PI});

    public static double encoderTicksToInches(double ticks) {
        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;
    }

    public static double rpmToVelocity(double rpm) {
        return rpm * GEAR_RATIO * 2 * Math.PI * WHEEL_RADIUS / 60.0;
    }

    public static double getMotorVelocityF(double ticksPerSecond) {
        return 32767 / ticksPerSecond;
    }
}
`
}

export interface TrajectoryStatistics {
  totalDistance: number
  estimatedTime: number
  maxVelocity: number
  maxAcceleration: number
  numberOfTurns: number
  averageHeadingChange: number
}

export function calculateTrajectoryStatistics(waypoints: Waypoint[]): TrajectoryStatistics {
  let totalDistance = 0
  let estimatedTime = 0
  let maxVelocity = 0
  let maxAcceleration = 0
  let numberOfTurns = 0
  let totalHeadingChange = 0

  for (let i = 1; i < waypoints.length; i++) {
    const prev = waypoints[i - 1]
    const curr = waypoints[i]

    // Calculate distance
    const distance = Math.sqrt(
      (curr.x - prev.x) ** 2 + (curr.y - prev.y) ** 2
    )
    totalDistance += distance

    // Track constraints
    const velocity = curr.maxVelocity || 50
    const acceleration = curr.maxAcceleration || 30
    maxVelocity = Math.max(maxVelocity, velocity)
    maxAcceleration = Math.max(maxAcceleration, acceleration)

    // Estimate time using trapezoidal motion profile
    const timeToMaxVel = velocity / acceleration
    const accelDistance = 0.5 * acceleration * timeToMaxVel ** 2

    if (distance < 2 * accelDistance) {
      // Triangle profile (doesn't reach max velocity)
      estimatedTime += 2 * Math.sqrt(distance / acceleration)
    } else {
      // Trapezoid profile
      const cruiseDistance = distance - 2 * accelDistance
      estimatedTime += 2 * timeToMaxVel + cruiseDistance / velocity
    }

    // Track turns
    const headingChange = Math.abs(curr.heading - prev.heading)
    totalHeadingChange += headingChange

    const distanceMoved = distance
    if (distanceMoved < 1 && headingChange > 5) {
      numberOfTurns++
    }
  }

  return {
    totalDistance,
    estimatedTime,
    maxVelocity,
    maxAcceleration,
    numberOfTurns,
    averageHeadingChange: totalHeadingChange / (waypoints.length - 1 || 1)
  }
}
