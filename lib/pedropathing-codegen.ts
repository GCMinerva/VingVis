import { Waypoint } from '@/components/interactive-field-canvas'

export type PedroPathingConfig = {
  projectName: string
  waypoints: Waypoint[]
  usePathBuilder: boolean
  constraints: {
    maxVelocity: number
    maxAcceleration: number
    maxAngularVelocity: number
    maxAngularAcceleration: number
  }
  followerConstants: {
    xMovement: number
    yMovement: number
    forwardZeroPowerAcceleration: number
    lateralZeroPowerAcceleration: number
    zeroPowerAccelerationMultiplier: number
  }
}

export function generatePedroPathingCode(config: PedroPathingConfig): string {
  const {
    projectName,
    waypoints,
    usePathBuilder,
    constraints,
    followerConstants
  } = config

  if (waypoints.length === 0) {
    return '// No waypoints defined'
  }

  const className = projectName.replace(/[^a-zA-Z0-9]/g, '') + 'Auto'

  let code = `package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;

import com.pedropathing.follower.Follower;
import com.pedropathing.localization.Pose;
import com.pedropathing.pathgen.BezierCurve;
import com.pedropathing.pathgen.BezierLine;
import com.pedropathing.pathgen.Path;
import com.pedropathing.pathgen.PathChain;
import com.pedropathing.pathgen.Point;
import com.pedropathing.util.Constants;

/**
 * Generated by VingVis - Robot Path Planner
 * Visit: https://vingvis.com
 */
@Autonomous(name = "${projectName} (PedroPathing)")
public class ${className} extends OpMode {
    private Follower follower;
    private Path path;

    /**
     * This initializes the Follower and creates the path.
     * Additionally, this initializes the FTC Dashboard.
     */
    @Override
    public void init() {
        // Initialize Follower with custom constants
        follower = new Follower(hardwareMap);

        // Set custom follower constants
        follower.setMaxPower(1.0);

        // Configure path constraints
        Constants.setMaxVelocity(${constraints.maxVelocity});
        Constants.setMaxAcceleration(${constraints.maxAcceleration});
        Constants.setMaxAngularVelocity(${constraints.maxAngularVelocity});
        Constants.setMaxAngularAcceleration(${constraints.maxAngularAcceleration});

        // Configure follower constants
        Constants.xMovement = ${followerConstants.xMovement};
        Constants.yMovement = ${followerConstants.yMovement};
        Constants.forwardZeroPowerAcceleration = ${followerConstants.forwardZeroPowerAcceleration};
        Constants.lateralZeroPowerAcceleration = ${followerConstants.lateralZeroPowerAcceleration};
        Constants.zeroPowerAccelerationMultiplier = ${followerConstants.zeroPowerAccelerationMultiplier};

        // Build path
        ${usePathBuilder ? generatePathBuilderCode(waypoints) : generatePathChainCode(waypoints)}

        telemetry.addData("Status", "Initialized");
        telemetry.addData("Waypoints", ${waypoints.length});
        telemetry.update();
    }

    /**
     * This runs the OpMode, updating the Follower as well as printing out the debug statements to
     * the Telemetry, as well as the FTC Dashboard.
     */
    @Override
    public void loop() {
        follower.update();

        // Telemetry
        telemetry.addData("X", follower.getPose().getX());
        telemetry.addData("Y", follower.getPose().getY());
        telemetry.addData("Heading", Math.toDegrees(follower.getPose().getHeading()));
        telemetry.addData("Following Path", follower.isBusy());
        telemetry.update();
    }

    /**
     * This runs once after the OpMode is stopped.
     */
    @Override
    public void stop() {
        follower.breakFollowing();
    }
}
`

  return code
}

function generatePathBuilderCode(waypoints: Waypoint[]): string {
  const startWaypoint = waypoints[0]

  let code = `// Using PathBuilder API for more control
        path = follower.pathBuilder()
            .addPath(
                // Start pose: x=${startWaypoint.x}", y=${startWaypoint.y}", heading=${startWaypoint.heading}°
                new BezierLine(
                    new Point(${startWaypoint.x}, ${startWaypoint.y}, Point.CARTESIAN),
                    new Point(${startWaypoint.x}, ${startWaypoint.y}, Point.CARTESIAN)
                )
            )
            .setLinearHeadingInterpolation(Math.toRadians(${startWaypoint.heading}), Math.toRadians(${startWaypoint.heading}))\n`

  for (let i = 1; i < waypoints.length; i++) {
    const prevWaypoint = waypoints[i - 1]
    const waypoint = waypoints[i]

    code += `            .addPath(
                // Waypoint ${i}: x=${waypoint.x}", y=${waypoint.y}", heading=${waypoint.heading}°\n`

    if (waypoint.type === 'bezier' && prevWaypoint.controlPoint1 && prevWaypoint.controlPoint2) {
      // Cubic Bézier curve with control points
      code += `                new BezierCurve(
                    new Point(${prevWaypoint.x}, ${prevWaypoint.y}, Point.CARTESIAN),
                    new Point(${prevWaypoint.controlPoint1.x}, ${prevWaypoint.controlPoint1.y}, Point.CARTESIAN),
                    new Point(${prevWaypoint.controlPoint2.x}, ${prevWaypoint.controlPoint2.y}, Point.CARTESIAN),
                    new Point(${waypoint.x}, ${waypoint.y}, Point.CARTESIAN)
                )\n`
    } else if (waypoint.type === 'spline') {
      // Smooth spline (use BezierCurve with auto-calculated control points)
      const cp1X = prevWaypoint.x + (waypoint.x - prevWaypoint.x) * 0.33
      const cp1Y = prevWaypoint.y + (waypoint.y - prevWaypoint.y) * 0.33
      const cp2X = prevWaypoint.x + (waypoint.x - prevWaypoint.x) * 0.66
      const cp2Y = prevWaypoint.y + (waypoint.y - prevWaypoint.y) * 0.66

      code += `                new BezierCurve(
                    new Point(${prevWaypoint.x}, ${prevWaypoint.y}, Point.CARTESIAN),
                    new Point(${cp1X.toFixed(2)}, ${cp1Y.toFixed(2)}, Point.CARTESIAN),
                    new Point(${cp2X.toFixed(2)}, ${cp2Y.toFixed(2)}, Point.CARTESIAN),
                    new Point(${waypoint.x}, ${waypoint.y}, Point.CARTESIAN)
                )\n`
    } else {
      // Linear (BezierLine)
      code += `                new BezierLine(
                    new Point(${prevWaypoint.x}, ${prevWaypoint.y}, Point.CARTESIAN),
                    new Point(${waypoint.x}, ${waypoint.y}, Point.CARTESIAN)
                )\n`
    }

    code += `            )
            .setLinearHeadingInterpolation(Math.toRadians(${prevWaypoint.heading}), Math.toRadians(${waypoint.heading}))`

    // Add velocity constraints if specified
    if (waypoint.maxVelocity && waypoint.maxVelocity !== 50) {
      code += `
            .setPathEndVelocityConstraint(${waypoint.maxVelocity})`
    }

    if (waypoint.maxAcceleration && waypoint.maxAcceleration !== 30) {
      code += `
            .setPathEndAccelerationConstraint(${waypoint.maxAcceleration})`
    }

    code += '\n'
  }

  code += `            .build();

        // Start following the path
        follower.followPath(path);`

  return code
}

function generatePathChainCode(waypoints: Waypoint[]): string {
  const startWaypoint = waypoints[0]

  let code = `// Using PathChain for sequential paths
        PathChain pathChain = follower.pathBuilder()
            .addPath(
                new BezierLine(
                    new Point(${startWaypoint.x}, ${startWaypoint.y}, Point.CARTESIAN),
                    new Point(${startWaypoint.x}, ${startWaypoint.y}, Point.CARTESIAN)
                )
            )
            .setLinearHeadingInterpolation(Math.toRadians(${startWaypoint.heading}), Math.toRadians(${startWaypoint.heading}))\n`

  for (let i = 1; i < waypoints.length; i++) {
    const prevWaypoint = waypoints[i - 1]
    const waypoint = waypoints[i]

    code += `            .addPath(
                new `

    if (waypoint.type === 'bezier' && prevWaypoint.controlPoint1 && prevWaypoint.controlPoint2) {
      code += `BezierCurve(
                    new Point(${prevWaypoint.x}, ${prevWaypoint.y}, Point.CARTESIAN),
                    new Point(${prevWaypoint.controlPoint1.x}, ${prevWaypoint.controlPoint1.y}, Point.CARTESIAN),
                    new Point(${prevWaypoint.controlPoint2.x}, ${prevWaypoint.controlPoint2.y}, Point.CARTESIAN),
                    new Point(${waypoint.x}, ${waypoint.y}, Point.CARTESIAN)
                )\n`
    } else {
      code += `BezierLine(
                    new Point(${prevWaypoint.x}, ${prevWaypoint.y}, Point.CARTESIAN),
                    new Point(${waypoint.x}, ${waypoint.y}, Point.CARTESIAN)
                )\n`
    }

    code += `            )
            .setLinearHeadingInterpolation(Math.toRadians(${prevWaypoint.heading}), Math.toRadians(${waypoint.heading}))\n`
  }

  code += `            .buildChain();

        // Start following the path chain
        follower.followPath(pathChain, /* holdEnd= */ true);`

  return code
}

export function generateAdvancedPedroConfig(): string {
  return `package org.firstinspires.ftc.teamcode;

import com.pedropathing.localization.*;
import com.pedropathing.util.Constants;

public class PedroPathingConfig {
    static {
        // Centimeter configuration
        Constants.setCmPerTick(0.01); // Adjust based on your encoders

        // Localizer configuration
        // Option 1: OTOS (Optical Tracking Odometry Sensor)
        // Constants.setOTOS(new OTOSLocalizer(hardwareMap));

        // Option 2: Three-wheel odometry
        // Constants.setLocalizer(new ThreeWheelLocalizer(...));

        // Option 3: Two-wheel + IMU
        // Constants.setLocalizer(new TwoWheelIMULocalizer(...));

        // Path following constants
        Constants.setMaxVelocity(50); // inches per second
        Constants.setMaxAcceleration(30); // inches per second squared
        Constants.setMaxAngularVelocity(Math.toRadians(180)); // radians per second
        Constants.setMaxAngularAcceleration(Math.toRadians(120)); // radians per second squared

        // PIDF coefficients for path following
        Constants.xMovement = 0.08;
        Constants.yMovement = 0.08;
        Constants.forwardZeroPowerAcceleration = -40;
        Constants.lateralZeroPowerAcceleration = -50;
        Constants.zeroPowerAccelerationMultiplier = 4.5;

        // Heading correction
        Constants.headingP = 2.0;
        Constants.headingI = 0.0;
        Constants.headingD = 0.1;

        // Drive correction
        Constants.driveP = 0.1;
        Constants.driveI = 0.0;
        Constants.driveD = 0.01;

        // Centripetal force correction
        Constants.useCentripetal = true;
        Constants.centripetalScaling = 0.0005;
    }
}
`
}

export interface PathStatistics {
  totalDistance: number
  totalTime: number
  averageVelocity: number
  maxVelocity: number
  numberOfSegments: number
  segmentTypes: {
    linear: number
    spline: number
    bezier: number
  }
}

export function calculatePathStatistics(waypoints: Waypoint[]): PathStatistics {
  let totalDistance = 0
  let totalTime = 0
  let maxVelocity = 0

  const segmentTypes = {
    linear: 0,
    spline: 0,
    bezier: 0
  }

  for (let i = 1; i < waypoints.length; i++) {
    const prev = waypoints[i - 1]
    const curr = waypoints[i]

    // Calculate segment distance (simplified)
    const distance = Math.sqrt(
      (curr.x - prev.x) ** 2 + (curr.y - prev.y) ** 2
    )
    totalDistance += distance

    // Track segment types
    segmentTypes[curr.type]++

    // Calculate time based on velocity
    const velocity = curr.maxVelocity || 50
    maxVelocity = Math.max(maxVelocity, velocity)
    totalTime += distance / velocity
  }

  return {
    totalDistance,
    totalTime,
    averageVelocity: totalDistance / totalTime || 0,
    maxVelocity,
    numberOfSegments: waypoints.length - 1,
    segmentTypes
  }
}
